package com.wonkglorg.util.converter.date;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.time.Duration;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.ToLongFunction;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class TimeBuilderNew {
	/**
	 * Pattern to match any valid int + datatype pair checks for numbers or decimal numbers followed
	 * by any amount of spaces and uppercase / lowercase letters
	 */
	private static final Pattern PATTERN = Pattern.compile("(\\d+(?:[.,]\\d+)?)\\s*([a-zA-ZÂµ]+)");
	private static final Comparator<DateType> COMPARATOR_BIGGEST_TIME_FIRST =
			Comparator.comparingLong(DateType::getMilliseconds).reversed();
	private static final Set<DateType> ALL_TYPES =
			Arrays.stream(DateType.values()).collect(Collectors.toSet());
	/**
	 * Caches correct ordering for each set of given DateTypes removing the need to sort them for
	 * future uses. This can be disabled setting {@link #CACHED_TYPES} to false
	 */
	private static final Map<Set<DateType>, List<DateType>> CACHED_TYPES = new ConcurrentHashMap<>();
	private static final BigInteger NANO_DIVIDER = BigInteger.valueOf(1_000_000_000L);

	//--------------Time--------------
	private final long nanos;
	private final long seconds;

	//--------------Flags--------------

	private boolean forceAllValues = false;
	private boolean trimTrailingDecimalZeros = true;
	private int maxDecimalsToShow = 2;
	private boolean useFullName = false;
	private boolean capitalizeFirstLetter = true;
	private final Set<DateType> formats = new HashSet<>();


	private TimeBuilderNew(long seconds, long nanos) {
		this.seconds = seconds;
		this.nanos = nanos;
	}

	public static TimeBuilderNew create(BigInteger nanoTime) {
		int compare = nanoTime.compareTo(BigInteger.ZERO);
		if (compare < 0) {
			throw new IllegalArgumentException("Time cannot be negative!");
		} else if (compare == 0) {
			return new TimeBuilderNew(0, 0);
		} else {
			BigInteger[] divAndRemainder = nanoTime.divideAndRemainder(NANO_DIVIDER);
			long seconds = divAndRemainder[0].longValue();
			long nanos = divAndRemainder[1].longValue();
			if (nanos < 0) {
				nanos += 1_000_000_000L;
				seconds -= 1;
			}

			return new TimeBuilderNew(seconds, nanos);
		}
	}

	public static TimeBuilderNew create(Duration duration) {
		if (duration.isNegative()) {
			throw new IllegalArgumentException("Time cannot be negative!");
		} else {
			return new TimeBuilderNew(duration.getSeconds(), duration.getNano());
		}
	}


	public static TimeBuilderNew create(String timeString) {
		long[] time = parseString(timeString);
		return new TimeBuilderNew(time[0], time[1]);
	}

	/**
	 * If set, shows the rest as decimal places if otherwise truncates the decimals if the selected
	 * {@link DateType}s can't hold all the values
	 *
	 * @param maxDecimalsToShow how many decimal places to show
	 * @param trimTrailingDecimalZeros if true removes any trailing 0's generated by the
	 * maxDecimals
	 */
	public TimeBuilderNew decimal(int maxDecimalsToShow, boolean trimTrailingDecimalZeros) {
		this.trimTrailingDecimalZeros = trimTrailingDecimalZeros;
		this.maxDecimalsToShow = maxDecimalsToShow;
		return this;
	}


	/**
	 * Forces all types to be shown in the resul even if they aren't relevant to the current
	 * results
	 * size (will not apply if a specified {@link #typesToShow(DateType...)} is given
	 */
	public TimeBuilderNew forceShowAllTypes() {
		this.forceAllValues = true;
		return this;
	}

	/**
	 * Which types to show in the output, if not specified shows only the ones selected or all if
	 * {@link #forceShowAllTypes()} is set
	 *
	 * @param types the types to show
	 */
	public TimeBuilderNew typesToShow(DateType... types) {
		formats.addAll(Arrays.asList(types));
		return this;
	}


	/**
	 * Helper method to convert the time to a human-readable format with customisations
	 *
	 * @param time the time to convert
	 * @param timeConversion the conversion to apply to the datatype
	 * @param useFullNames weather to use the full name to display or the shortened names
	 * @param capitalizeFirstLetter when full names are enabled convert the first letter of the
	 * name
	 * to capital
	 * @param forceAllTypes forces all possible datatypes to be displayed even if their value is 0
	 * @param formats which formats to show if non are selected and forceAllTypes is off splits
	 * them
	 * into all formats that this value fits in biggest to smallest
	 * @return the human-readable time string.
	 */
	private String convertTimeToString(long time, ToLongFunction<DateType> timeConversion,
			boolean useFullNames, boolean capitalizeFirstLetter, boolean forceAllTypes,
			Set<DateType> formats) {
		List<DateType> dateList = CACHED_TYPES.computeIfAbsent(formats,
				v -> formats.stream().sorted(COMPARATOR_BIGGEST_TIME_FIRST).toList());

		StringBuilder sb = new StringBuilder();
		boolean isLastDateType;

		for (int i = 0; i < dateList.size(); i++) {
			DateType dateType = dateList.get(i);
			long dateTypeTime = timeConversion.applyAsLong(dateType);
			//TODO, check if value is small enough to be compared etc
			if (dateTypeTime <= 0) {
				if (forceAllTypes) {
					String name = timePostfix(dateType, 0, useFullNames, capitalizeFirstLetter);
					sb.append("%d%s ".formatted(0, name));
				}
				continue; // Skip if value is too small
			}
			isLastDateType = (i == dateList.size() - 1);

			long value = time / dateTypeTime;
			if (!isLastDateType) {
				time %= dateTypeTime;
			}

			// weather or not this is the last type in the list
			if ((value > 0 || forceAllTypes)) {
				if (isLastDateType) {
					double decimalValue = (double) time / dateTypeTime;
					String name = timePostfix(dateType, 3, useFullNames, capitalizeFirstLetter);
					sb.append("%s%s".formatted(
							formatDecimal(decimalValue, maxDecimalsToShow, trimTrailingDecimalZeros), name));
				} else {
					String name = timePostfix(dateType, value, useFullNames, capitalizeFirstLetter);
					sb.append(value).append(name).append(" ");
					//sb.append("%d%s ".formatted(value, name));
				}
			}
		}

		return sb.toString().trim();
	}


	private String formatDecimal(double decimalValue, int maxDecimalPlaces,
			boolean trimTrailingZeros) {

		BigDecimal bigDecimal =
				BigDecimal.valueOf(decimalValue).setScale(maxDecimalPlaces, RoundingMode.HALF_UP);
		if (trimTrailingZeros) {
			return bigDecimal.stripTrailingZeros().toPlainString();
		}
		return bigDecimal.toPlainString();
	}

	private String timePostfix(DateType type, long value, boolean useFullName,
			boolean capitalizeFirstLetter) {
		if (!useFullName) {
			return type.getPostfix();
		}
		String name = " " + type.getFullNameSingular();

		if (!capitalizeFirstLetter) {
			name = name.toLowerCase();
		}
		if (value > 1) {
			name = name + "s";
		}

		return name;
	}


	/**
	 * Converts a String to its representing seconds and nanoseconds
	 * @param timeString the string to parse
	 * @return a 2 element long array where index 0 is seconds and index 1 is nanoseconds
	 */
	private static long[] parseString(String timeString) {
		if (timeString == null || timeString.isBlank()) {
			return new long[]{0, 0};
		}
		long nanos = 0;
		long seconds = 0;

		Matcher matcher = PATTERN.matcher(timeString);
		while (matcher.find()) {
			double value = parseValue(matcher.group(1));
			String suffix = matcher.group(2);

			DateType type = DateType.fromIdentifier(suffix);
			if (type != null) {
				if (type.typeStoredInNanos()) {
					nanos += (long) (type.getNanoseconds() * value);
				} else {
					seconds += (long) (type.getSeconds() * value);
				}
			}
		}

		seconds += nanos / 1_000_000_000;
		nanos = nanos % 1_000_000_000;

		return new long[]{seconds, nanos};
	}


	/**
	 * Parses a string value to either long or double depending on which is applicable
	 *
	 * @param stringValue the value to parse
	 * @return the parsed value
	 */
	private static double parseValue(String stringValue) {
		if(stringValue.contains(",")) {
			stringValue = stringValue.replace(",", ".");
		}
		try {
			return Long.parseLong(stringValue);
		} catch (NumberFormatException e) {
			try {
				return Double.parseDouble(stringValue);
			} catch (NumberFormatException ex) {
				throw new IllegalArgumentException("Invalid value for time parsing: " + stringValue);
			}
		}
	}

	public long toMillis() {
		return ((seconds * 1_000) + (nanos / 1_000_000));
	}


}
