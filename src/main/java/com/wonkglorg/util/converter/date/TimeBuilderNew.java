package com.wonkglorg.util.converter.date;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class TimeBuilderNew {
	/**
	 * Pattern to match any valid int + datatype pair checks for numbers or decimal numbers followed
	 * by any amount of spaces and uppercase / lowercase letters
	 */
	private static final Pattern PATTERN = Pattern.compile("(\\d+(?:[.,]\\d+)?)\\s*([a-zA-ZÂµ]+)");
	private static final Comparator<DateType> COMPARATOR_BIGGEST_TIME_FIRST =
			Comparator.comparingLong(DateType::getMilliseconds).reversed();
	private static final Set<DateType> ALL_TYPES =
			Arrays.stream(DateType.values()).collect(Collectors.toSet());
	/**
	 * Caches correct ordering for each set of given DateTypes removing the need to sort them for
	 * future uses. This can be disabled setting {@link #CACHED_TYPES} to false
	 */
	private static final Map<Set<DateType>, List<DateType>> CACHED_TYPES = new ConcurrentHashMap<>();
	private static final BigInteger NANO_DIVIDER = BigInteger.valueOf(1_000_000_000L);

	//--------------Time--------------
	private final long nanos;
	private final long seconds;

	//--------------Flags--------------

	private boolean forceAllValues = false;
	private boolean trimTrailingDecimalZeros = true;
	private int maxDecimalsToShow = 2;
	private boolean useFullName = false;
	private boolean capitalizeFirstLetter = true;
	private final Set<DateType> formats = new HashSet<>();


	private TimeBuilderNew(long seconds, long nanos) {
		this.seconds = seconds;
		this.nanos = nanos;
	}

	public static TimeBuilderNew create(BigInteger nanoTime) {
		int compare = nanoTime.compareTo(BigInteger.ZERO);
		if (compare < 0) {
			throw new IllegalArgumentException("Time cannot be negative!");
		} else if (compare == 0) {
			return new TimeBuilderNew(0, 0);
		} else {
			BigInteger[] divAndRemainder = nanoTime.divideAndRemainder(NANO_DIVIDER);
			long seconds = divAndRemainder[0].longValue();
			long nanos = divAndRemainder[1].longValue();
			if (nanos < 0) {
				nanos += 1_000_000_000L;
				seconds -= 1;
			}

			return new TimeBuilderNew(seconds, nanos);
		}
	}

	public static TimeBuilderNew create(long time, DateType type) {
		if (time == 0) {
			return new TimeBuilderNew(0, 0);
		}

		//todo:jmd properly set data type? Best case without BigInts for performance

		return new TimeBuilderNew(time.mu);
	}


	public static TimeBuilderNew create(String timeString) {
		return new TimeBuilderNew();
	}

	/**
	 * If set, shows the rest as decimal places if otherwise truncates the decimals if the selected
	 * {@link DateType}s can't hold all the values
	 *
	 * @param maxDecimalsToShow how many decimal places to show
	 * @param trimTrailingDecimalZeros if true removes any trailing 0's generated by the
	 * maxDecimals
	 */
	public TimeBuilderNew decimal(int maxDecimalsToShow, boolean trimTrailingDecimalZeros) {
		this.trimTrailingDecimalZeros = trimTrailingDecimalZeros;
		this.maxDecimalsToShow = maxDecimalsToShow;
		return this;
	}


	/**
	 * Forces all types to be shown in the resul even if they aren't relevant to the current
	 * results
	 * size (will not apply if a specified {@link #typesToShow(DateType...)} is given
	 */
	public TimeBuilderNew forceShowAllTypes() {
		this.forceAllValues = true;
		return this;
	}

	/**
	 * Which types to show in the output, if not specified shows only the ones selected or all if
	 * {@link #forceShowAllTypes()} is set
	 *
	 * @param types the types to show
	 */
	public TimeBuilderNew typesToShow(DateType... types) {
		formats.addAll(Arrays.asList(types));
		return this;
	}


}
